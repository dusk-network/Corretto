\\\ Base point compututation

sage: def findBasepoint(prime, A):
....:        F = GF(prime)
....:        E = EllipticCurve(F, [0, A, 0, 1, 0])
....: 
....:        for uInt in range(1, 1e3):
....:          u = F(uInt)
....:          v2 = u^3 + A*u^2 + u
....:          if not v2.is_square():
....:            continue
....:          v = v2.sqrt()
....:          point = E(u, v)
....:          pointOrder = point.order()
....:          if pointOrder > 8 and pointOrder.is_prime():
....:             Q=u^3 + A*u^2 + u
....:             return u, Q, sqrt(Q), point
....:        
sage: prime = 2^252 + 27742317777372353535851937790883648493
sage: A = 505186
sage: res = findBasepoint(prime, A)
sage: res
(4,
 8083044,
 2387694734969974503585694617203302024142786955946516383730480941479078023877,
 (4 : 2387694734969974503585694617203302024142786955946516383730480941479078023877 : 1))



/// Computation of edwards points in twisted format to produce (X:Y:T:Z) from given X value.
/// Using a manipulated version of the Edwards equation,
/// written below, allows for the computation.
/// a*x^2+y^2 = 1+d*x^2*y^2
/// a = -1, d = -126296/126297
/// In fractions in the mod l need to be `inverse_mod`, calculated for d as below:

sage: p = 2^252 + 27742317777372353535851937790883648493
sage: d = -(126296)/(126297)
sage: d = ((-126296)*inverse_mod(126297,p))%p
sage: d
951605751702391019481481818669129158712512026257330939079110344917983315091

/// For use in the equation y^2 will be written as y, as sage will attempt to compute the square root.
/// For arbitrarlily chosen x = 23

sage: x = 14
sage: y = (-(x)^2-1)*inverse_mod(d*(x)^2-1,p)%p
sage: y

4097294349129061626216953635182512769012007176856180609903321124717525537317

/// It needs to be checked if the y here is a quadratic residue in p,
/// using the legendre symbol [http://people.bath.ac.uk/masgks/XX10190/legendresymbol.pdf],
/// if confirmed as QR in p, then tonelli-shanks is used to find the corresponing Y coordinates.

sage: legendre_symbol(y,p)
1
sage:         z += 1
....:     c = pow(z, q, p)
....:
....:     # Search for a solution
....:     x = pow(a, (q + 1)/2, p)
....:     t = pow(a, q, p)
....:     m = s
....:     while t != 1:
....:         # Find the lowest i such that t^(2^i) = 1
....:         i, e = 0, 2
....:         for i in xrange(1, m):
....:             if pow(t, e, p) == 1:
....:                 break
....:             e *= 2
....:
....:         # Update next value to iterate
....:         b = pow(c, 2**(m - i - 1), p)
....:         x = (x * b) % p
....:         t = (t * b * b) % p
....:         c = (b * b) % p
....:         m = i
....:
....:     return [x, p-x]
....:
sage: prime_mod_sqrt(y,p)
[7027685437011822135117075804201712829494335458984232261155589991678118276875,
 209320140320440078856110758841281411362780900395675344846360946607335974114]

/// Using formulae from (http://eprint.iacr.org/2008/522), Section 3.1., compute T.
/// Set initial Z = 1

sage: X = 14 
sage: Y = 20932014032044007885611075884128141136278090039567534
....: 4846360946607335974114
sage: T = (X*Y)%p
sage: T
2930481964486161103985550623777939759078932605539454827849053252502703637596
sage: Z = 1 
sage: print X, Y, T, Z
14, 
209320140320440078856110758841281411362780900395675344846360946607335974114, 
2930481964486161103985550623777939759078932605539454827849053252502703637596, 
1

///Using formulae from (http://eprint.iacr.org/2008/522), Section 3.1.
/// We can perform addition for twisted edwards on two points computed
/// using the aforementioned method. Addition requires two points, P and Q.

X3 = (X1Y2 + Y1X2)(Z1Z2 − d*T1T2),
Y3 = (Y1Y2 − a*X1X2)(Z1Z2 + d*T1T2),
T3 = (Y1Y2 − a*X1X2)(X1Y2 + Y1X2),
Z3 = (Z1Z2 − d*T1T2)(Z1Z2 + d*T1T2)
///all of the above operations are to be performed in modp

/// For the computation between points, using the formulas provided by h hisil at isi qut edu au, we must first obtain 
/// another set of coordiates in the same manner. 

sage: x = 67
sage: y = (-(x)^2-1)*inverse_mod(d*(x)^2-1,p)%p
sage: legendre_symbol(y,p)
1
sage: def prime_mod_sqrt(a, p):
....:     """
....:     Square root modulo prime number
....:     Solve the equation
....:         x^2 = a mod p
....:     and return list of x solution
....:     http://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm
....: 
....:     """
....:     a %= p
....: 
....:     # Simple case
....:     if a == 0:
....:         return [0]
....:     if p == 2:
....:         return [a]
....: 
....:     # Check solution existence on odd prime
....:     if legendre_symbol(a, p) != 1:
....:         return []
....: 
....:     # Simple case
....:     if p % 4 == 3:
....:         x = pow(a, (p + 1)/4, p)
....:         return [x, p-x]
....: 
....:     # Factor p-1 on the form q * 2^s (with Q odd)
....:     q, s = p - 1, 0
....:     while q % 2 == 0:
....:         s += 1
....:         q //= 2
....: 
....:     # Select a z which is a quadratic non resudue modulo 
....: p
....:     z = 1
....:     while legendre_symbol(z, p) != -1:
....:         z += 1
....:     c = pow(z, q, p)
....: 
....:     # Search for a solution
....:     x = pow(a, (q + 1)/2, p)
....:     t = pow(a, q, p)
....:     m = s
....:     while t != 1:
....:         # Find the lowest i such that t^(2^i) = 1
....:         i, e = 0, 2
....:         for i in xrange(1, m):
....:             if pow(t, e, p) == 1:
....:                 break
....:             e *= 2
....: 
....:         # Update next value to iterate
....:         b = pow(c, 2**(m - i - 1), p)
....:         x = (x * b) % p
....:         t = (t * b * b) % p
....:         c = (b * b) % p
....:         m = i
....: 
....:     return [x, p-x]
....: 
sage: prime_mod_sqrt(y,p)
[3941153185566030503197827307080909868202351422646487319508322021660996132587,
 3295852391766231710775359255962084372654764936733420286493628916624458118402]
sage: X = 67 
sage: Y = 32958523917662317107753592559620843726547649367334202
....: 86493628916624458118402
sage: T = X*Y%p 
sage: T
3711942928369658202753473258169825742155759979741931015014609265275066403264
sage: Z = 1 
sage: print X, Y, T, Z
67, 
3295852391766231710775359255962084372654764936733420286493628916624458118402, 
3711942928369658202753473258169825742155759979741931015014609265275066403264, 
1

/// To compute the points, uses the calculated values
sage: X1 = 14 
sage: Y1 = 2093201403204400788561107588412814113627809003956753
....: 44846360946607335974114
sage: T1 = 2930481964486161103985550623777939759078932605539454
....: 827849053252502703637596
sage: Z1 = 1 
sage: X2 = 67
sage: Y2 = 3295852391766231710775359255962084372654764936733420
....: 286493628916624458118402
sage: T2 = 3711942928369658202753473258169825742155759979741931
....: 015014609265275066403264
sage: Z2 = 1


sage: print a,d  
-1, 951605751702391019481481818669129158712512026257330939079110344917983315091

sage: print p
7237005577332262213973186563042994240857116359379907606001950938285454250989

sage: X3 = ((X1*Y2+Y1*X2)*(Z1*Z2-d*T1*T2))%p
sage: Y3 = ((Y1*Y2-a*X1*X2)*(Z1*Z2+d*T1*T2))%p
sage: Y3 = ((Y1*y2-a*X1*X2)*(X1*Y2+Y1*X2))%p
sage: Z3 = ((Z1*Z2-d*T1*T2)*(Z1*Z2+d*T1*T2))%p
sage: print X3, Y3, T3, Z3
6071577539228590191219387911031602982956051495655581694654126271979753651722, 
837202702872841412924343780706778248153230580612427863707303374823451692769, 
3870569102798123767101920828945730089305537575358572428982223506408632563886, 5030678076965133398451320860257582818948884882165145613987735041289292101393

///Using formulae from (http://eprint.iacr.org/2008/522), Section 3.1.
/// We can perform doubling for twisted edwards on two points computed
/// using the aforementioned method. Doubling requires only one point, P.

X3 = 2X1Y1(2*Z1^2-Y1^2-a*X1^2)
Y3 = (Y1^2+a*X1^2)(Y1^2-a*X1^2)
T3 = 2X1Y1(Y1^2-a*X1^2)
Z3 = (Y1^2+a*X1^2)(2*Z1^2-Y1^2-a*X1^2)

sage: print X1, Y1, T1, Z1
14, 
209320140320440078856110758841281411362780900395675344846360946607335974114, 
2930481964486161103985550623777939759078932605539454827849053252502703637596, 
1
sage: print a,d  
-1, 1201935917638644956968126114584555454358623906841733991436515590915937358637
sage: print p
7237005577332262213973186563042994240857116359379907606001950938285454250989
 
sage: X3 = (2*X1*Y1)*(2*Z1^2-Y1^2-a*X1^2)%p
sage: Y3 = (Y1^2+a*X1^2)*(X1^2-a*X1^2)%p
sage: T3 = ((2*X1*Y1)*(Y1^2-a*X1^2))%p
sage: Z3 = (Y1^2+a*X1^2)*(2*X1^2-Y1^2-a*X1^2)%p
sage: print X3, Y3, T3, Z3
149787030802898863214220589614787467360377956858885734134859441157998105502, 
4114181249139963708922561672280278463269518807069632207462778037420327721750, 
465221815300404819953157336686579853418396566040992296296754217912562254655, 
3604554139948105518509753594085031057181477091926039562012636801913890184366



/// For scalar multiplication, where the input is a random chosen
/// scalar - denoted by k. A random point P is computed k times,
/// to achieve a new output. First define constants and algorithm
/// then perform computation and check.

sage: x = 2^252 + 27742317777372353535851937790883648493
sage: F = GF(x) 
sage: E = EllipticCurve(F,[0,505186,0,1,0])
sage:  def mult(P,k):
....:      if k == 0:
....:          return E(0)
....:      elif k%2 ==1:
....:         return P + mult(P+P,k//2)
....:      else:
....:         return mult(P+P,k//2)
....:    
sage: P = E.random_element();P
(5051189995337479708433119006747039364870785988521470496097671181243562411695 : 
7155958472685660389975401207154951743382380416674787893210035445445872196541 : 
1)
sage: mult(P,8)
(1868330701290932041393248498391407583880515981499204757603220260047257156875 :
 5999066270237031196158421153363394298942525294456370395071609058345162660448 : 
 1)
sage: 8*P
(1868330701290932041393248498391407583880515981499204757603220260047257156875 :
 5999066270237031196158421153363394298942525294456370395071609058345162660448 : 
 1)
